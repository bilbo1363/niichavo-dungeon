# Архитектура проекта: Подземелье НИИЧАВО (Python)

## 1. Общая архитектура

### 1.1 Архитектурный паттерн
**ECS (Entity-Component-System)** с элементами MVC на Python

```
┌─────────────────────────────────────────────┐
│           Presentation Layer                │
│  (UI, Canvas Rendering, Input Handling)     │
└─────────────────┬───────────────────────────┘
                  │
┌─────────────────▼───────────────────────────┐
│           Game Logic Layer                  │
│  (Game Loop, State Management, Systems)     │
└─────────────────┬───────────────────────────┘
                  │
┌─────────────────▼───────────────────────────┐
│           Data Layer                        │
│  (Entities, Components, Level Data)         │
└─────────────────────────────────────────────┘
```

---

## 2. Модульная структура

### 2.1 Структура директорий

```
Gold/
├── src/
│   ├── core/                    # Ядро игры
│   │   ├── game.py             # Главный класс игры
│   │   ├── game_loop.py        # Игровой цикл
│   │   ├── state_manager.py    # Управление состояниями
│   │   └── event_bus.py        # Шина событий
│   │
│   ├── entities/               # Игровые сущности
│   │   ├── entity.py           # Базовый класс сущности
│   │   ├── player.py           # Игрок
│   │   ├── enemy.py            # Враги
│   │   ├── npc.py              # NPC
│   │   ├── rune.py             # Руны стабилизации
│   │   └── item.py             # Предметы
│   │
│   ├── components/             # Компоненты ECS
│   │   ├── position_component.py
│   │   ├── health_component.py
│   │   ├── inventory_component.py
│   │   ├── combat_component.py
│   │   └── ai_component.py
│   │
│   ├── systems/                # Системы ECS
│   │   ├── movement_system.py
│   │   ├── combat_system.py
│   │   ├── ai_system.py
│   │   ├── render_system.py
│   │   └── collision_system.py
│   │
│   ├── world/                  # Мир игры
│   │   ├── level.py            # Класс уровня
│   │   ├── level_generator.py # Генератор уровней
│   │   ├── floor_state.py     # Состояние этажа (для рун)
│   │   ├── tile.py             # Тайлы
│   │   ├── room.py             # Комнаты
│   │   ├── rune_system.py     # Система рун
│   │   └── corridor.py         # Коридоры
│   │
│   ├── combat/                 # Боевая система
│   │   ├── Weapon.ts           # Оружие
│   │   ├── Spell.ts            # Заклинания
│   │   ├── DamageCalculator.ts # Расчет урона
│   │   └── StatusEffect.ts     # Статусные эффекты
│   │
│   ├── crafting/               # Система крафта
│   │   ├── Recipe.ts           # Рецепты
│   │   ├── CraftingStation.ts  # Станции крафта
│   │   └── Material.ts         # Материалы
│   │
│   ├── quest/                  # Система квестов
│   │   ├── quest.py            # Квесты
│   │   ├── quest_manager.py    # Менеджер квестов
│   │   ├── coordinate_puzzle.py # Загадка координат
│   │   └── objective.py        # Цели квестов
│   │
│   ├── ui/                     # Пользовательский интерфейс
│   │   ├── UIManager.ts        # Менеджер UI
│   │   ├── Menu.ts             # Меню
│   │   ├── HUD.ts              # HUD
│   │   ├── Inventory.ts        # Инвентарь
│   │   └── Dialog.ts           # Диалоги
│   │
│   ├── rendering/              # Рендеринг
│   │   ├── Renderer.ts         # Главный рендерер
│   │   ├── Camera.ts           # Камера
│   │   ├── SpriteManager.ts    # Менеджер спрайтов
│   │   ├── ParticleSystem.ts   # Система частиц
│   │   └── LightingSystem.ts   # Система освещения
│   │
│   ├── input/                  # Управление вводом
│   │   ├── InputManager.ts     # Менеджер ввода
│   │   ├── KeyboardHandler.ts  # Клавиатура
│   │   └── MouseHandler.ts     # Мышь
│   │
│   ├── audio/                  # Звук
│   │   ├── AudioManager.ts     # Менеджер аудио
│   │   ├── SoundEffect.ts      # Звуковые эффекты
│   │   └── MusicPlayer.ts      # Музыка
│   │
│   ├── data/                   # Данные
│   │   ├── game_data.py        # Игровые данные
│   │   ├── save_manager.py     # Сохранения (pickle)
│   │   └── config.py           # Конфигурация
│   │
│   └── utils/                  # Утилиты
│       ├── random_utils.py     # Генератор случайных чисел
│       ├── pathfinding.py      # Поиск пути (A*)
│       ├── math_utils.py       # Математические функции
│       └── logger.py           # Логирование
│
├── assets/                     # Ресурсы
│   ├── sprites/                # Спрайты
│   ├── sounds/                 # Звуки
│   ├── music/                  # Музыка
│   └── data/                   # Данные (JSON)
│
├── tests/                      # Тесты
│   ├── unit/                   # Юнит-тесты
│   └── integration/            # Интеграционные тесты
│
├── docs/                       # Документация
│   ├── api/                    # API документация
│   └── guides/                 # Руководства
│
├── public/                     # Публичные файлы
│   ├── index.html
│   └── favicon.ico
│
├── config/                     # Конфигурация
│   ├── game_config.yaml
│   └── settings.yaml
│
├── requirements.txt            # Зависимости
├── requirements-dev.txt        # Dev зависимости
├── setup.py                    # Установка пакета
├── pyproject.toml             # Конфигурация проекта
└── main.py                    # Точка входа
```

---

## 3. Ключевые компоненты

### 3.1 Game (Главный класс)

```typescript
class Game {
    private stateManager: StateManager;
    private renderer: Renderer;
    private inputManager: InputManager;
    private audioManager: AudioManager;
    private world: World;
    private player: Player;
    
    constructor() {
        this.initialize();
    }
    
    initialize(): void {
        // Инициализация всех систем
    }
    
    start(): void {
        // Запуск игрового цикла
    }
    
    update(deltaTime: number): void {
        // Обновление игровой логики
    }
    
    render(): void {
        // Отрисовка кадра
    }
}
```

### 3.2 ECS Architecture

#### Entity (Сущность)
```typescript
class Entity {
    id: string;
    components: Map<string, Component>;
    
    addComponent(component: Component): void;
    removeComponent(componentType: string): void;
    getComponent<T>(componentType: string): T;
    hasComponent(componentType: string): boolean;
}
```

#### Component (Компонент)
```typescript
interface Component {
    type: string;
}

class PositionComponent implements Component {
    type = 'position';
    x: number;
    y: number;
}

class HealthComponent implements Component {
    type = 'health';
    current: number;
    max: number;
}
```

#### System (Система)
```typescript
abstract class System {
    abstract requiredComponents: string[];
    
    abstract update(entities: Entity[], deltaTime: number): void;
}

class MovementSystem extends System {
    requiredComponents = ['position', 'velocity'];
    
    update(entities: Entity[], deltaTime: number): void {
        entities.forEach(entity => {
            const pos = entity.getComponent<PositionComponent>('position');
            const vel = entity.getComponent<VelocityComponent>('velocity');
            
            pos.x += vel.x * deltaTime;
            pos.y += vel.y * deltaTime;
        });
    }
}
```

### 3.3 State Management

```typescript
enum GameState {
    MENU,
    PLAYING,
    PAUSED,
    INVENTORY,
    DIALOG,
    GAME_OVER
}

class StateManager {
    private currentState: GameState;
    private states: Map<GameState, State>;
    
    setState(newState: GameState): void {
        this.states.get(this.currentState)?.exit();
        this.currentState = newState;
        this.states.get(this.currentState)?.enter();
    }
    
    update(deltaTime: number): void {
        this.states.get(this.currentState)?.update(deltaTime);
    }
}
```

### 3.4 Event System

```typescript
class EventBus {
    private listeners: Map<string, Function[]>;
    
    on(event: string, callback: Function): void {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event)!.push(callback);
    }
    
    emit(event: string, data?: any): void {
        this.listeners.get(event)?.forEach(callback => {
            callback(data);
        });
    }
    
    off(event: string, callback: Function): void {
        const callbacks = this.listeners.get(event);
        if (callbacks) {
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }
}
```

---

## 4. Генерация уровней

### 4.1 Алгоритм генерации

```typescript
class LevelGenerator {
    generateLevel(width: number, height: number, depth: number): Level {
        const level = new Level(width, height, depth);
        
        // 1. Генерация комнат
        const rooms = this.generateRooms(width, height);
        
        // 2. Соединение комнат коридорами
        const corridors = this.connectRooms(rooms);
        
        // 3. Размещение объектов
        this.placeObjects(level, rooms);
        
        // 4. Размещение врагов
        this.placeEnemies(level, rooms, depth);
        
        // 5. Размещение предметов
        this.placeItems(level, rooms);
        
        return level;
    }
    
    private generateRooms(width: number, height: number): Room[] {
        // BSP (Binary Space Partitioning) или случайное размещение
    }
    
    private connectRooms(rooms: Room[]): Corridor[] {
        // A* или простые L-образные коридоры
    }
}
```

### 4.2 Процедурная генерация контента

```typescript
class ContentGenerator {
    generateEnemy(level: number): Enemy {
        const enemyType = this.selectEnemyType(level);
        const stats = this.scaleStats(enemyType.baseStats, level);
        return new Enemy(enemyType, stats);
    }
    
    generateLoot(level: number, rarity: Rarity): Item {
        const itemPool = this.getItemPool(level, rarity);
        return this.selectRandomItem(itemPool);
    }
}
```

---

## 5. Система сохранений

### 5.1 Структура сохранения

```typescript
interface SaveData {
    version: string;
    timestamp: number;
    player: {
        position: { x: number; y: number; level: number };
        stats: PlayerStats;
        inventory: ItemData[];
        equipment: EquipmentData;
        skills: SkillData[];
    };
    world: {
        currentLevel: number;
        levels: LevelData[];
        discoveredAreas: boolean[][];
    };
    quests: QuestData[];
    gameTime: number;
}

class SaveManager {
    save(slot: number): void {
        const saveData = this.serializeGameState();
        localStorage.setItem(`save_${slot}`, JSON.stringify(saveData));
    }
    
    load(slot: number): SaveData | null {
        const data = localStorage.getItem(`save_${slot}`);
        return data ? JSON.parse(data) : null;
    }
    
    private serializeGameState(): SaveData {
        // Сериализация текущего состояния игры
    }
}
```

---

## 6. Оптимизация производительности

### 6.1 Object Pooling

```typescript
class ObjectPool<T> {
    private pool: T[] = [];
    private factory: () => T;
    
    constructor(factory: () => T, initialSize: number = 10) {
        this.factory = factory;
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(factory());
        }
    }
    
    acquire(): T {
        return this.pool.pop() || this.factory();
    }
    
    release(obj: T): void {
        this.pool.push(obj);
    }
}
```

### 6.2 Spatial Partitioning

```typescript
class QuadTree {
    private boundary: Rectangle;
    private capacity: number;
    private entities: Entity[] = [];
    private divided: boolean = false;
    private children: QuadTree[] = [];
    
    insert(entity: Entity): boolean {
        // Вставка сущности в квадродерево
    }
    
    query(range: Rectangle): Entity[] {
        // Поиск сущностей в области
    }
}
```

### 6.3 Dirty Flag Pattern

```typescript
class RenderSystem {
    private dirtyEntities: Set<Entity> = new Set();
    
    markDirty(entity: Entity): void {
        this.dirtyEntities.add(entity);
    }
    
    render(): void {
        // Отрисовка только измененных сущностей
        this.dirtyEntities.forEach(entity => {
            this.renderEntity(entity);
        });
        this.dirtyEntities.clear();
    }
}
```

---

## 7. Тестирование

### 7.1 Юнит-тесты

```typescript
describe('Player', () => {
    let player: Player;
    
    beforeEach(() => {
        player = new Player();
    });
    
    test('should take damage', () => {
        const initialHealth = player.health;
        player.takeDamage(10);
        expect(player.health).toBe(initialHealth - 10);
    });
    
    test('should not go below 0 health', () => {
        player.takeDamage(1000);
        expect(player.health).toBe(0);
    });
});
```

### 7.2 Интеграционные тесты

```typescript
describe('Combat System', () => {
    test('player attacks enemy', () => {
        const player = new Player();
        const enemy = new Enemy();
        const combatSystem = new CombatSystem();
        
        const initialEnemyHealth = enemy.health;
        combatSystem.attack(player, enemy);
        
        expect(enemy.health).toBeLessThan(initialEnemyHealth);
    });
});
```

---

## 8. Развертывание

### 8.1 Сборка проекта

```json
// package.json
{
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "jest",
    "lint": "eslint src --ext .ts"
  }
}
```

### 8.2 CI/CD Pipeline

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
      - name: Build
        run: npm run build
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./dist
```

---

## 9. Масштабируемость

### 9.1 Модульность
- Каждая система независима
- Легко добавлять новые компоненты
- Возможность отключения систем

### 9.2 Расширяемость
- Плагинная архитектура для модов
- API для пользовательского контента
- Система событий для интеграций

### 9.3 Производительность
- Ленивая загрузка ресурсов
- Асинхронная генерация уровней
- Web Workers для тяжелых вычислений
